---
title: 创建型设计模式汇总分析
date: 2017-05-24 08:50:45
tags:
	- 设计模式
---
创建型设计模式抽象了实例化的过程，他们可以帮助某个系统独立于如何创建、组合以及表示该系统所包含的对象。主要围绕两个基本点。
* 他们都将某个系统使用到了哪些具体的类这个信息封装起来
* 进一步隐藏了那些具体的类的实例是如何被创建并且放到一起的。

<!--more-->
创建型模式关心的点是：创建了什么 ， 什么时候创建， 创建的方式 由什么来创建。
## 工厂方法模式
定义： 定义一个用于创建对象的接口，让子类决定实例化那一个类。工厂方法使得一个类的实例化延迟到其子类。

主要是不希望使用者知道那几个类进行实例化操作，或者简化自己实例化操作的一些麻烦（主要是如果有固定参数的情况下）.
### 模式结构
### 适用范围
* 当一个类不需要它所必须创建的对象的类时。
* 当一个类希望由它的子类来指定它所在的对象时。
* 当类将创建对象的职责委托给多个帮助子类中的一个，并且希望子类代理者一部分的信息局部化时。


## 抽象工厂模式（最重要的）
定义：抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类（依赖接口不依赖具体的实现）

违背了开放-封闭原则 添加新产品麻烦

分离了客户端和后台逻辑 实现简单，易于操作。
### 模式结构
### 适用范围
* 一个系列要独立于它的产品的创建、组合和表示时
* 一个系统要由多个产品系列中的一个来配置时
* 当要强调一些列相关产品对象的设计以便进行联合使用时
* 当要提供一个产品类库，而知识显示它们的接口而不是实现时。


## 单例模式
定义： 保证一个类仅有一个实例，并且提供一个访问它的全局访问点。

就是简单的一个类之能有一个实例（呜呜）

```
import java.util.concurrent.locks.Lock;

/**
 * Created by forvoid on 5/24/2017.
 */
public class Singleton {
    private static Singleton singInstance;
    private static Lock lock;
    private Singleton(){//内部访问

    }
    public static Singleton getSingInstance(){
        if (singInstance == null){
            lock.lock();
            if (singInstance == null){
                singInstance = new Singleton();
            }
            lock.unlock();

        }
        return singInstance;
    }
}

```
### 懒汉模式和恶汉模式（面试中问道了呜呜悲哀）
懒汉模式：饿汉模式的特点是加载类时比较慢，但运行是比较快-线程安全
```
private static Singleton instance ;//在引用创建模式的时候才进行
```
饿汉模式：饿汉模式的特点是加载类时比较慢，但运行是比较快-`线程安全`。
```
private static Singleton instance = new Singleton();//在开始加载类的时候就把类初始化。
	
	public static Singleton getInstance(){
		return instance;
	}

```
### 模式结构
### 适用范围
* 当类只能有一个实例
* 当一个唯一的实例可以通过子类化来扩展，而且第三方需要在不修改代码的情况下就能使用这个扩展的实例时。


## 建造者模式（创建不同的对象）
定义： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

就是将构造和逻辑分开。把构造作为一个完整的单独任务去完成。
### 模式结构
### 适用范围
* 当需要把构造对象的实例的逻辑转移到类的外面去，这个类的外部去定义其构造逻辑。
* 当需要按照某种步骤去构造对象时。


## 原型模式
定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

就是复制对象的一种设计模式，只是有些复制可以个性化的设置，或者修改。

使用克隆的方式时要注意 `深复制`（当变量有对象时，新建一个对象，然后引用到新的那个变量）和`浅复制`（如果变量是对象时，直接复制原有的引用）。（Cloneable）
### 模式结构
### 适用范围
* 当要实例化的类是在运行时刻指定时。
* 为了避免创建一个产品类层次并行的工厂类层次时。
* 当一个类的实例只能有几个不同状态组合中的一种时。


## 总结
总的来说，就是和开头一样，创建型模式就是去思考如何去创建一些相对于特定环境下，满足或者尽量满足六大设计模式的的情况下的类的对象。这些对象的创建要优雅，并且能让我们的程序开发更加的爽。

各种设计模式感觉还是很多的，对于如何去合理的在代码中服务还是有点困难的。之前没学过设计模式很多都感觉自己想到的一些简便的写法，都觉得自己很了不起（可以写出这种代码， 哈哈哈）,但是在看了设计模式的，学习了设计模式。感觉写出感觉很精巧的代码应该是常态化的，写不出来，才是很丢人的 呜呜 Fight!!!!
